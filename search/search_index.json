{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"DSA/introduction/","title":"What are Data Structures & Algorithms?","text":"<p>Data structures and algorithms are fundamental concepts in computer science that are used to organize and process data in efficient ways. A data structure is a specific way of organizing and storing data in a computer, such as a list, a tree, or a graph, while an algorithm is a step-by-step process for solving a problem or accomplishing a task.</p> <p>There are many reasons why someone might want to learn about data structures and algorithms. Some of the key benefits include:</p> <ul> <li> <p>Improved problem-solving skills: Learning about data structures and algorithms can help you develop a systematic approach to solving problems, which can be useful in many areas of life.</p> </li> <li> <p>Better performance: Using the right data structure and algorithm for a given task can significantly improve the performance of a computer program. This can be especially important in large or complex systems where performance is critical.</p> </li> <li> <p>Increased efficiency: Data structures and algorithms can help you design more efficient solutions to problems, which can save time and resources.</p> </li> <li> <p>Greater flexibility: Knowing about different data structures and algorithms can give you more options for solving problems, which can make you more versatile and adaptable as a programmer.</p> </li> </ul> <p>So, learning about data structures and algorithms can be a valuable investment for anyone who is interested in computer science or programming. It can provide a strong foundation for understanding many other concepts in these fields, and can help you develop important skills that can be useful in many different situations.</p> <p>This is a list of must have knowledge recommend it by Gayle Laakmann McDowell:</p> Info <p>Check Cracking the Coding Inverview to know more about Gayle Laakmann McDowell.</p> Data Structures Algorithms Concepts Linked Lists Breadth-First Search Bit Manipulation Stacks &amp; Queues Depth-First Search Memory (Stacks vs. Heap) Trees,Tries &amp; Graphs Binary Search Recursion Heaps Merge Sort Dynamic Programming Vector/ArrayLists Quick Sort Big O time &amp; Space Hash Tables"},{"location":"DSA/01/amortizedtime/","title":"Armotized Time","text":"<p>In computer science, the amortized time of an algorithm is the average time it takes to run a single operation, over a large number of operations. It's a way of measuring the efficiency of an algorithm, by taking into account not just the time it takes to run each operation, but also the number of operations and how they are grouped together.</p> <p>For example, let's say you have an algorithm that can add items to a list, and it takes one second to add an item to a list of 10 items, two seconds to add an item to a list of 100 items, and five seconds to add an item to a list of 1000 items. The time it takes to add an item to the list is different depending on the size of the list, but the amortized time of the algorithm is the average time it takes to add an item, over a large number of items.</p> <p>In big O notation, the amortized time of an algorithm is represented by a function that describes how the time it takes to run the algorithm grows, as the input size grows. For example, if the amortized time of an algorithm is \\(O(1)\\), it means that the algorithm takes the same amount of time to run, no matter how big the input is. If the amortized time is \\(O(n)\\), it means that the time it takes to run the algorithm grows linearly with the size of the input. And if the amortized time is \\(O(n^2)\\), it means that the time it takes to run the algorithm grows exponentially with the size of the input.</p>"},{"location":"DSA/01/bigo/","title":"What is Big O?","text":"<p>Big O notation is a mathematical notation that is used to describe the performace or complexity of an algorith. It's a way of expressing how the number of operations that an algorithm performs scales as the input size grows.</p> More resources <ul> <li>Big O Cheat Sheet</li> <li>Free Code Camp Big O</li> </ul> <p></p> <p>Another thing to add is that there are multiple ways to describe asymptotic notation like Big Omega and Big Theta, but I'm going to use the Big O that is used in the industry, just Big O, which offers the tightest description of a runtime.</p>"},{"location":"DSA/01/howtoreadbigo/","title":"How to read Big O","text":"<p>Remember that \\(n\\) indicates the input size, so what we what to do is to count the inputs we have in your code.  I'm going to use the most basic examples for time complexity but also I'm going to explain space complexity, because you need to understand the basic ones before jumping to the fancy ones like \\(2^n\\), \\(n\\,log\\,(n)\\) or \\(n!\\).</p> <p>4 rules to read Big O more easily:</p> <ol> <li>Read Worst Case.</li> <li>Remove Constasts.</li> <li>Different terms for inputs.</li> <li>Drop Non Dominats.</li> </ol> <p>\\(Eg:\\)</p> \\(O(1)\\)\\(O(n)\\)\\(O(n^2)\\)\\(O(n+m)\\)\\(O(n*m)\\)\\(O(log(n))\\) <pre><code>function sayHi(){\n    return `Hi`; // 1 time and space\n}\n</code></pre> <p><code>sayHi()</code> always return <code>Hi</code>, so the space complexity of this function is constant, as it does not create any additional variables or data structures and simply returns a string. The time complexity of this function is also constant, as it always takes the same amount of time to execute regardless of the input size. In other words, the function has a space and time complexity of \\(O(1)\\).</p> <p><pre><code>function sayHi( n ){\n    hiArray = [] // n spaces\n\n    for(let i = 1; n &gt;= i; i++) hiArray.push(`Hi`); // n times\n\n    return hiArray;\n}\n</code></pre> The time complexity of this function is linear, or \\(O(n)\\), because the for loop iterates a number of times equal to the input value<code>n</code>. Each iteration of the loop takes constant time to execute, so the total time complexity is directly proportional to the input size.</p> <p>The space complexity of this function is also linear, or \\(O(n)\\), because a new array is created and its length is equal to the input value n. The array requires additional space to store each element that is added to it, so the total space complexity is directly proportional to the input size.</p> <p>In summary, the time complexity of this function is \\(O(n)\\) and the space complexity is \\(O(n)\\).</p> <p><pre><code>function GenerateMultiplicationTablesFromOneToNinNTimes( n ){\n    result = {} // n spaces \n\n    for(let i = 1; i &lt;= n; i++){ // n times\n        let table = [] // spaces\n        for( j = 1; j &lt;= n; j++ ){ // n times\n            table.push(j*i)\n        }\n        result[i] = table;\n    } // n times\n\n    return result;\n}\n</code></pre> The space complexity of this function is \\(O(n)\\), as it creates an object with n keys, as well as n arrays of size <code>n</code>. The time complexity of this function is \\(O(n^2)\\), as the outer for loop runs n times and the inner for loop also runs n times, resulting in \\(n * n = n^2\\) iterations. This means that the overall time complexity of this function is \\(O(n^2)\\).</p> When a function doesn't count as \\(O(n^2)\\) in a double loop? \\(E.g\\;1\\):\\(E.g\\;2\\): <p><pre><code>function GenerateMultiplicationTablesFromOneTo10(){\n    result = {} // 10 spaces \n\n    for(let i = 1; i &lt;= 10; i++){ // 10 times\n        let table = [] // 10 spaces \n        for( j = 1; j &lt;= 10; j++ ){ // 10 times\n            table.push(j*i)\n        }\n        result[i] = table;\n    }\n\n    return result;\n}\n</code></pre> The time it takes to execute the function grows proportionally with the input size. This result in a total of \\(n * n = n^2\\) iterations. In this case, the input size is the upper limit of the for loop, which is 10. So the function has a space and time complexity of \\(O(n) = O(10) = O(1)\\).</p> <pre><code>function GenerateMultiplicationTablesFromOneToN( n ){\n    result = {} // n spaces \n\n    for(let i = 1; i &lt;= n; i++){ // n times\n        let table = [] // 10 spaces\n        for( j = 1; j &lt;= 10; j++ ){ // 10 times\n            table.push(j*i)\n        }\n        result[i] = table;\n    }\n\n    return result;\n}\n</code></pre> <p>The time complexity of this one is \\(O(n)\\) because even if we double loop in time complexity is \\(O(n * 10) = O(n)\\) and in space and time.</p> <pre><code>function sum(nArr, mArr) {\n    let sum = 0; // 1 space\n\n    for(let i : nArr) { // n times\n        sum += i; // 1 space\n    }\n\n    for(let i : mArr) { // m times\n        sum += i; // 1 space\n    }\n\n    return sum;\n}\n</code></pre> <p>When you write O(m+n) it means that the algorithm will take O(m) time when \\(m&gt;n\\) and \\(O(n)\\) when \\(m&lt;n\\). In any way, \\(O(m+n) = O(max(m,n))\\) This is because the function performs a fixed number of operations (i.e., adding each element to the sum) for each element in the input arrays. The space complexity is also linear, \\(O(n)\\), because the function stores a sum variable and two pointers (i) for each element in the input arrays. But try to use the third rule written before, to be clear about the time complexity.</p> <pre><code>function sum(nArr, mArr) {\n    let sum = 0; // 1 space\n\n    for(let i : nArr) { // n times\n        for(let j : mArr) { // m times \n            sum += i * j; // 1 space\n        }\n    }\n\n    return sum;\n}\n</code></pre> <p>This function has \\(O(m*n)\\) time complexity because it performs a nested loop, with the outer loop iterating over each element in <code>nArr</code> and the inner loop iterating over each element in <code>mArr</code>. For each element in nArr, the function performs m operations (one for each element in <code>mArr</code>), so the total number of operations is \\(m * n\\). The space complexity of this function is also \\(O(m*n)\\), because it stores the sum variable and two pointers (i and j) for each element in the input arrays.</p> <pre><code>function binarySearch(arr, x) {\n    let start = 0; // 1 space\n\n    let end = arr.length - 1; // space\n\n    while (start &lt;= end) { // log(n) time, because the search space is halved on each iteration of the loop\n        let mid = start + (end - start) / 2; // 1 space\n        if (arr[mid] === x) {\n            return mid; // n times\n        } else if (arr[mid] &lt; x) {\n            start = mid + 1; // n times\n        } else {\n            end = mid - 1; // n times\n        }\n    }\n\n    return -1;\n}\n</code></pre> <p>Here is a simple implementation of a binary search algorithm, this algorithm works by first setting the start and end indices of the search space to the first and last elements of the array. It then repeatedly divides the search space in half by setting the midpoint as the new start or end index, depending on whether the element being searched for is greater than or less than the element at the midpoint. This process continues until the element is found, or until the search space is empty (in which case the element is not present in the array).</p> <p>The time complexity of this algorithm is \\(O(log(n))\\), because the size of the search space is halved on each iteration of the loop, so the number of iterations required to find the element is logarithmic in the size of the array.</p> <p>The space complexity of this algorithm is \\(O(1)\\), because it only uses a constant number of variables (start, end, and mid) regardless of the size of the input array. This means that the amount of memory used by the algorithm does not depend on the size of the input, so the space complexity is constant.</p>"},{"location":"DSA/01/timeandspacecomplexity/","title":"Time & Space Complexity","text":"<p>Time complexity and space complexity are ways of describing how efficient an algorithm is. An algorithm is a set of steps for solving a problem, such as finding the biggest number in a list of numbers.</p> <p>Time complexity is a measure of how long an algorithm takes to run, depending on the size of the input it's given. For example, if you have a list of 10 numbers, it might take the algorithm one second to find the biggest number. But if you have a list of 100 numbers, it might take the algorithm two seconds, and if you have a list of 1000 numbers, it might take the algorithm five seconds. As the size of the input grows, the time it takes for the algorithm to run grows too.</p> <p>Space complexity is a measure of how much memory an algorithm needs to run, depending on the size of the input. For example, if you have a list of 10 numbers, the algorithm might need to use 10 bytes of memory to store the numbers and keep track of them. But if you have a list of 100 numbers, the algorithm might need to use 100 bytes of memory, and if you have a list of 1000 numbers, the algorithm might need to use 1000 bytes of memory. As the size of the input grows, the amount of memory the algorithm needs to run grows too.</p> <p>Time and space complexity are important because they tell us how well an algorithm can scale. If an algorithm has a good time and space complexity, it will be able to solve big problems quickly and efficiently, even if the input is very large. But if an algorithm has a bad time or space complexity, it might be slow or use up too much memory, which can make it difficult to use for big problems.</p>"},{"location":"DSA/01/typesofbigo/","title":"Types of Big O'S","text":"<ul> <li>\\(O(1)\\) Constant - no loops.</li> <li>\\(O(log N)\\) Logarithmic - usually searching algorithms have log n if they are sorted (Binary Search).</li> <li>\\(O(n)\\) Linear - for loops, while loops through n items.</li> <li>\\(O(n log(n))\\) Log Linear - usually sorting operations, where you half the half.</li> <li>\\(O(n^2)\\) Quadratic - every element in a collection needs to be compared to every other element. Two nested loops.</li> <li>\\(O(2^n)\\) Exponential - recursive algorithms that solves a problem of size N.</li> <li>\\(O(n!)\\) Factorial - you are adding a loop for every element.</li> </ul> <p>Note</p> <p>Iterating through half a collection is still \\(O(n)\\)</p> <p>Two separate collections is \\(O(a*b)\\)</p> Big O Name Description \\(1\\) Constant Statement, one line code \\(log(n)\\) Logarithmic Divide and conquer (binary search) \\(n\\) Linear Loop \\(n\\,log(n)\\) Linearithmic Effective sorting algorithms \\(n^2\\) Quadratic Double loop \\(n^3\\) Cubic Triple loop \\(2^n\\) Exponential Complex full search"},{"location":"DSA/01/whatsalogarithm/","title":"Logarithms","text":"<p>If you don't like math that much, don't worry\u2014I\u2019ll explain this using a simple real-life scenario that you might find interesting. Keep in mind that this will be the hardest math you'll use, and since it's arithmetic, it's not that hard. Even so, I\u2019m not going to lie; it took me three tries to fully understand logarithms. First, I'll explain what they are, and if you already know, you can skip to the next question.</p>"},{"location":"DSA/01/whatsalogarithm/#whats-a-logarithm","title":"What's a Logarithm?","text":"<p>A logarithm is like the opposite of exponentiation, just as division is the reverse of multiplication. They\u2019re great for handling big numbers, like on the Richter scale for earthquakes, where each increase by 1 represents a tenfold rise in amplitude. The trick? Just count the zeroes!</p> <p>The Richter magnitude \\( M \\) is calculated as:</p> \\[ M = \\log_{10}(A) \\] <p>For example: - An amplitude of \\( 10 \\) = magnitude \\( 1 \\) - An amplitude of \\( 1,000 \\) = magnitude \\( 3 \\) - An amplitude of \\( 100,000 \\) = magnitude \\( 5 \\)</p> <p>Specific cases:</p> \\[ \\log_{10}(10) = 1, \\quad \\log_{10}(1,000) = 3, \\quad \\log_{10}(100,000) = 5 \\] <p>The basic logarithmic formula without exponents is:</p> \\[ \\log_b(x) = y \\quad \\text{if and only if} \\quad b^y = x \\] <p>So, if \\( \\log_{10}(10) = 1 \\), then \\( 10^1 = 10 \\). Similarly, \\( \\log_{10}(1,000) = 3 \\) means \\( 10^3 = 1,000 \\). Humans find base 10 easy, but computers use binary (base 2), which means bits are either on (1) or off (0). </p> <p>We use base 2 for computer stuff (this will change with quantum computers). For instance:</p> \\[ \\log_2(8) = 3 \\quad \\text{because} \\quad 2^3 = 8 \\] \\[ \\log_2(256) = 8 \\quad \\text{because} \\quad 2^8 = 256 \\]"},{"location":"DSA/01/whatsalogarithm/#why-are-logarithms-used-in-dsa","title":"Why Are Logarithms Used in DSA?","text":"<p>In Data Structures and Algorithms (DSA), logarithms are key. For example, in Binary Search, which halves the search space with each step, the time complexity is \\( O(\\log n) \\). For an array of size \\( n \\), it takes \\( \\log_2(n) \\) steps to find an item.</p> <p>Code</p> JSJavaC++PythonC# <pre><code>function binarySearch(arr, target) {\n\n    let left = 0, right = arr.length - 1; // Initialize search boundaries\n\n    while (left &lt;= right) {\n        const mid = Math.floor((left + right) / 2); // Find the middle index\n        if (arr[mid] === target) return mid; // Target found\n        if (arr[mid] &lt; target) left = mid + 1; // Adjust search range to the right\n        else right = mid - 1; // Adjust search range to the left\n    }\n\n    return -1; // Target not found\n}\n</code></pre> <pre><code>public class BinarySearch {\n\n    public static int binarySearch(int[] arr, int target) {\n        int left = 0, right = arr.length - 1; // Initialize search boundaries\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2; // Find the middle index\n\n            if (arr[mid] == target) return mid; // Target found\n\n            if (arr[mid] &lt; target) left = mid + 1; // Adjust search range to the right\n            else right = mid - 1; // Adjust search range to the left\n        }\n\n        return -1; // Target not found\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};\n        int target = 7;\n        System.out.println(binarySearch(arr, target)); // Output: 3 (index of the target)\n    }\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint binarySearch(const std::vector&lt;int&gt;&amp; arr, int target) {\n    int left = 0, right = arr.size() - 1; // Initialize search boundaries\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2; // Find the middle index\n\n        if (arr[mid] == target) return mid; // Target found\n\n        if (arr[mid] &lt; target) left = mid + 1; // Adjust search range to the right\n        else right = mid - 1; // Adjust search range to the left\n    }\n\n    return -1; // Target not found\n}\n\nint main() {\n    std::vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11, 13, 15};\n    int target = 7;\n    std::cout &lt;&lt; binarySearch(arr, target) &lt;&lt; std::endl; // Output: 3 (index of the target)\n    return 0;\n}\n</code></pre> <pre><code>def binary_search(arr, target):\n    left, right = 0, len(arr) - 1  # Initialize search boundaries\n\n    while left &lt;= right:\n        mid = (left + right) // 2  # Find the middle index\n\n        if arr[mid] == target:\n            return mid  # Target found\n        elif arr[mid] &lt; target:\n            left = mid + 1  # Adjust search range to the right\n        else:\n            right = mid - 1  # Adjust search range to the left\n\n    return -1  # Target not found\n\n# Example usage\narr = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 7\nprint(binary_search(arr, target))  # Output: 3 (index of the target)\n</code></pre> <pre><code>using System;\n\nclass Program\n{\n    // Method to perform binary search\n    public static int BinarySearch(int[] arr, int target)\n    {\n        int left = 0, right = arr.Length - 1; // Initialize search boundaries\n\n        while (left &lt;= right)\n        {\n            int mid = left + (right - left) / 2; // Find the middle index\n\n            if (arr[mid] == target)\n                return mid; // Target found\n\n            if (arr[mid] &lt; target)\n                left = mid + 1; // Adjust search range to the right\n            else\n                right = mid - 1; // Adjust search range to the left\n        }\n\n        return -1; // Target not found\n    }\n\n    static void Main()\n    {\n        int[] arr = { 1, 3, 5, 7, 9, 11, 13, 15 };\n        int target = 7;\n        Console.WriteLine(BinarySearch(arr, target)); // Output: 3 (index of the target)\n    }\n}\n</code></pre> <p>In a balanced Binary Search Tree (BST), the tree height is \\( \\log n \\), so operations like search, insert, and delete have a time complexity of \\( O(\\log n) \\). For a tree with 15 nodes, the height is \\( \\log_2(15) \\approx 4 \\), meaning about 4 steps from root to leaf. But we'll see that in the future.</p> <p>Just always keep in mind that logarithms make analyzing algorithms and data structures simpler and more efficient!</p>"},{"location":"DSA/02/divideandconquer/","title":"Divide & Conquer","text":"<p>This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data.</p> <p>THis pattern can tremendusly decrease time complexity.</p>"},{"location":"DSA/02/divideandconquer/#searcharr-val","title":"search(arr, val)","text":"<p>Given a sorted array of intergers, write a function called search, that accepts a value and returns the index where the value passed to a the function is located. If the value is not found, return -1. <pre><code>search([1,2,3,4,5,6],2) //3\nsearch([1,2,3,4,5,6],6) //5\nsearch([1,2,3,4,5,6],11) //-1\n</code></pre></p> <p>A Naive solution</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(1\\)</li> </ul> <pre><code>function search(arr, val){\n    for(let i=0; i &lt; arr.length; i++){\n        if(arr[i] === val) return arr[i];\n    }\n    return -1;\n}\n</code></pre> <p>Refactored</p> <ul> <li>Time complexity - \\(log(n)\\)</li> <li>Space complexity - \\(1\\)</li> </ul> JSJava <pre><code>function search(arr, val){\n\n    let min = 0;\n    let max = arr.length - 1;\n\n    while(min &lt;= max){\n        let middle = Math.floor((min + max) / 2);\n\n        if(arr[middle] &lt; val) {\n            min = middle + 1;\n        } else if(arr[middle] &gt; val) {\n            max = middle - 1;\n        } else {\n            return val;\n        }\n    }\n\n    return -1;\n}\n</code></pre> <pre><code>public class BinarySearch {\n    public static int search(int[] arr, int val) {\n        int min = 0;\n        int max = arr.length - 1;\n\n        while (min &lt;= max) {\n            int middle = (min + max) / 2;\n\n            if (arr[middle] == val) {\n                return middle; // return the index\n            } else if (arr[middle] &gt; val) {\n                max = middle - 1;\n            } else {\n                min = middle + 1;\n            }\n        }\n\n        return -1; // not found\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n\n        int index = search(arr, target);\n        if (index != -1) {\n            System.out.println(\"Found at index: \" + index);\n        } else {\n            System.out.println(\"Not found\");\n        }\n    }\n}\n</code></pre>"},{"location":"DSA/02/frequencycounter/","title":"Frequency Counter","text":"<p>This pattern uses objects or sets to collect values/frequencies of values.</p> <p>This can often avoid the need for nested loops or \\(O(n^2)\\) operations with arrays/strings.</p>"},{"location":"DSA/02/frequencycounter/#samearr1-arr2","title":"same(arr1, arr2)","text":"<p>Write a function called same, which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same. <pre><code>same([1,2,3], [4,1,9]) //true\nsame([1,2,3], [1,9]) //false\nsame([1,2,1], [4,4,9]) //true (must be the same frequency)\n</code></pre></p> <p>A Naive solution</p> <ul> <li>Time complexity - \\(n^2\\)</li> <li>Space complexity - \\(1\\)</li> </ul> <pre><code>function same(arr1, arr2){\n    if(arr1.length !== arr2.length){\n        return false;\n    }\n    for(let i=0; i&lt;arr1.length; i++){\n        let correctIndex = arr2.indexOf(arr1[i] ** 2)\n        if(correctIndex === -1){\n            return false;\n        }\n        arr2.splice(correctIndex,1)\n    }\n    return true\n}\n</code></pre> <p>Refactored</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(n\\)</li> </ul> JSJava <pre><code>function same(arr1, arr2){\n    if(arr1.length !== arr2.length){\n        return false;\n    }\n    let frequencyCounter1 = {}\n    let frequencyCounter2 = {}\n    for(let val of arr1){\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1\n    }\n    for(let val of arr2){\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1\n    }\n    for(let key in frequencyCounter1){\n        if(!(key ** 2 in frequencyCounter2)) return false\n        if(!(frequencyCounter2[key ** 2] !== frequencyCounter1[key])) return false\n    }\n    return true\n}\n</code></pre> <pre><code>public class Main {\n    public static boolean same(int[] arr1, int[] arr2) {\n        if (arr1.length != arr2.length) {\n            return false;\n        }\n\n        Map&lt;Integer, Integer&gt; frequencyCounter1 = new HashMap&lt;&gt;();\n        Map&lt;Integer, Integer&gt; frequencyCounter2 = new HashMap&lt;&gt;();\n        for (int val : arr1) {\n            frequencyCounter1.put(val, frequencyCounter1.getOrDefault(val, 0) + 1);\n        }\n        for (int val : arr2) {\n            frequencyCounter2.put(val, frequencyCounter2.getOrDefault(val, 0) + 1);\n        }\n        for (int key : frequencyCounter1.keySet()) {\n            if (!frequencyCounter2.containsKey(key * key)) return false;\n            if (!(frequencyCounter2.get(key * key) == frequencyCounter1.get(key))) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3};\n        int[] arr2 = {1, 4, 9};\n        System.out.println(same(arr1, arr2)); // true\n    }\n}\n</code></pre>"},{"location":"DSA/02/frequencycounter/#validanagramword1-word2","title":"validAnagram(word1, word2)","text":"<p>Given two strings, write a function called validAnagram to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman. <pre><code>validAnagram('', ''); // true\nvalidAnagram('aaz', 'zza'); // false\nvalidAnagram('anagram', 'nagaram'); // true\n</code></pre></p> <p>Solution</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(n\\)</li> </ul> JSJava <pre><code>function validAnagram(word1, word2){\n    if(word1.length !== word2.length) return false\n\n    let freqLetters1 = {}\n\n    for(let letter of word1){\n        freqLetters1[letter] = (freqLetters1[letter] || 0) + 1\n        //Also we can do it with a ternary operator\n        //freqLetters1[letter] ? freqLetters1[letter] += 1 : freqLetters1[letter] = 1;\n    }\n\n    for(let letter of word2){\n        if(!freqLetters1[letter]) return false\n        freqLetters1[letter]--;\n    }\n    return true;\n}\n</code></pre> <pre><code>public class Main {\n    public static boolean validAnagram(String word1, String word2) {\n        if (word1.length() != word2.length()) return false;\n\n        Map&lt;Character, Integer&gt; freqLetters1 = new HashMap&lt;&gt;();\n\n        for (char letter : word1.toCharArray()) {\n            freqLetters1.put(letter, freqLetters1.getOrDefault(letter, 0) + 1);\n        }\n\n        for (char letter : word2.toCharArray()) {\n            if (!freqLetters1.containsKey(letter)) return false;\n            freqLetters1.put(letter, freqLetters1.get(letter) - 1);\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(validAnagram(\"listen\", \"silent\"));  // true\n        System.out.println(validAnagram('awesome', 'awesom'));  // false\n    }\n}\n</code></pre>"},{"location":"DSA/02/multiplepointers/","title":"Multiple Pointers","text":"<p>Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition.</p> <p>Very efficient for solving problems with minimal space complexity as well.</p> <p>This pattern uses for strings, arrays or linkedlist to search a pair a value or to meet a condition.</p>"},{"location":"DSA/02/multiplepointers/#sumzeroarr","title":"sumZero(arr)","text":"<p>Write a function called sumZero, which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist. <pre><code>same([-3,-2,-1,0,1,2,3]) //[-3, 3]\nsame([-2,0,1,3]) //undefined\nsame([1,2,3]) //undefined\n</code></pre></p> <p>A Naive solution</p> <ul> <li>Time complexity - \\(n^2\\)</li> <li>Space complexity - \\(1\\)</li> </ul> <pre><code>function sumZero(arr){\n    for(let i=0; i&lt;arr.length; i++){\n        for(let j=i+1; j&lt;arr.length; j++){\n            if(arr[i] + arr[j] === 0){\n                return [arr[i], arr[j]];\n            }\n        }\n    }\n}\n</code></pre> <p>Refactored</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(n\\)</li> </ul> JSJava <pre><code>function sumZero(arr){\n    let left = 0;\n    let right = arr.length - 1;\n    while(left &lt; right){\n        let sum = arr[left] + arr[right];\n        if(sum === 0){\n            return [arr[left], arr[right]]\n        }else if(sum &gt; 0){\n            right--;\n        }else {\n            left++;\n        }\n    }\n}\n</code></pre> <pre><code>public class SumZero {\n\n    public static int[] sumZero(int[] arr) {\n        int left = 0;\n        int right = arr.length - 1;\n\n        while (left &lt; right) {\n            int sum = arr[left] + arr[right];\n\n            if (sum == 0) {\n                return new int[]{arr[left], arr[right]};\n            } else if (sum &gt; 0) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n\n        return null; // No pair found\n    }\n\n    public static void main(String[] args) {\n        int[] sortedArray = {-5, -3, -1, 0, 2, 4, 5};\n        int[] result = sumZero(sortedArray);\n\n        if (result != null) {\n            System.out.println(\"Pair: [\" + result[0] + \", \" + result[1] + \"]\");\n        } else {\n            System.out.println(\"No pair found.\");\n        }\n    }\n}\n</code></pre>"},{"location":"DSA/02/multiplepointers/#countuniquevaluesarr","title":"countUniqueValues(arr)","text":"<p>Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted. Bonus: You must do this with constant or O(1) space and O(n) time. <pre><code>countUniqueValues([1,1,1,1,1,2]) // 2\ncountUniqueValues([1,2,3,4,4,4,7,7,12,12,13]) // 7\ncountUniqueValues([]) // 0\ncountUniqueValues([-2,-1,-1,0,1]) // 4\n</code></pre></p> <p>Solution</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(1\\)</li> </ul> JSJava <pre><code>function countUniqueValues(arr){\n    if( arr.length === 0 ) return 0\n    if( arr.length === 1 ) return 1\n\n    let count = 0;\n    for( let i=0; i&lt;arr.length; i++)\n        if(arr[i] !== arr[i+1]) count++\n\n    return count\n}\n</code></pre> <pre><code>public class UniqueValueCounter {\n\n    public static int countUniqueValues(int[] arr) {\n        if (arr.length == 0) return 0;\n        if (arr.length == 1) return 1;\n\n        int count = 0;\n\n        for (int i = 0; i &lt; arr.length - 1; i++) {\n            if (arr[i] != arr[i + 1]) {\n                count++;\n            }\n        }\n\n        return count + 1; // +1 to count the last unique value\n    }\n\n    public static void main(String[] args) {\n        int[] sortedArray = {1, 1, 2, 2, 3, 4, 4, 5};\n        System.out.println(\"Unique values count: \" + countUniqueValues(sortedArray)); // \u279d 5\n    }\n}\n</code></pre>"},{"location":"DSA/02/slidingwindow/","title":"Sliding Window","text":"<p>This pattern involves creating a window which can either be an array or numbers from one position to another.</p> <p>Depending on a certain condition, the window either increases or closes(and a new window is created).</p> <p>Very useful for keeping track of a subset of data in an array/string etc.</p>"},{"location":"DSA/02/slidingwindow/#maxsubarraysumarr-num","title":"maxSubarraySum(arr, num)","text":"<p>Write a function called maxSubarraySum, which accepts a  array of integers and a number called num. The function should calculate the maximum sum of num consecutive elements in the array. <pre><code>maxSubarraySum([1,2,5,2,8,1,5],2) //10\nmaxSubarraySum([1,2,5,2,8,1,5],4) //17\nmaxSubarraySum([4,2,1,6],1) //6\nmaxSubarraySum([],4) //null\n</code></pre></p> <p>A Naive solution</p> <ul> <li>Time complexity - \\(n^2\\)</li> <li>Space complexity - \\(1\\)</li> </ul> <pre><code>function maxSubrraySum(arr, num){\n    if(num &gt; arr.length){\n        return null;\n    }\n    let max = -Infinity;\n    for(let i=0; i&lt;arr.length - num + 1; i++){\n        temp = 0;\n        for(let j=0; j&lt;num; j++){\n            temp += arr[i+j];\n        }\n        if(temp &gt; max){\n            max = temp;\n        }\n    }\n    return max;\n}\n</code></pre> <p>Refactored</p> <ul> <li>Time complexity - \\(n\\)</li> <li>Space complexity - \\(1\\)</li> </ul> JSJava <pre><code>function maxSubrraySum(arr, num){\n    let maxSum = 0;\n    let tempSum =0;\n\n    if(arr.length &lt; num) return null;\n\n    for(let i=0; i&lt;num;i++){\n        maxSum+=arr[i];\n    }\n\n    tempSum=maxSum;\n\n    for(let i=num; i&lt;arr.length; i++){\n        tempSum = tempSum - arr[i-num] + arr[i];\n        maxSum = Math.max(maxSum,tempSum);\n    }\n\n    return maxSum;\n}\n</code></pre> <pre><code>public class MaxSubarraySum {\n    public static Integer maxSubarraySum(int[] arr, int num) {\n        if (arr.length &lt; num) return null;\n\n        int maxSum = 0;\n        int tempSum = 0;\n\n        // Initial sum of the first `num` elements\n        for (int i = 0; i &lt; num; i++) {\n            maxSum += arr[i];\n        }\n\n        tempSum = maxSum;\n\n        // Sliding window\n        for (int i = num; i &lt; arr.length; i++) {\n            tempSum = tempSum - arr[i - num] + arr[i];\n            maxSum = Math.max(maxSum, tempSum);\n        }\n\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int[] example = {1, 2, 5, 2, 8, 1, 5};\n        int num = 4;\n        System.out.println(\"Max sum: \" + maxSubarraySum(example, num)); // Output: 17\n    }\n}\n</code></pre>"},{"location":"DSA/02/whataredatapatterns/","title":"What are Data Patterns?","text":"<p>Data patterns refer to the regularities or trends that exist within a dataset. In the context of data structures, these patterns can be used to inform the design and implementation of the data structure in order to optimize it for the specific types of data it will be storing and the operations that will be performed on that data.</p> <p>Tip</p> <p>When you are working in problems remember these principles to understand the problem:</p> <ol> <li>Understand the problems<ul> <li>Explicitly write out the steps you need to take.</li> </ul> </li> <li>Explore concrete examples<ul> <li>Start with simple examples and progress to more complex.</li> <li>Explore examples with empty and invalid inputs.</li> </ul> </li> <li>Break it down<ul> <li>Explicity write out the steps you need to take.</li> </ul> </li> <li>Solve/Simplify<ul> <li>Do I've enough info to solve the problem?</li> </ul> </li> <li>How should I label the important pieces of data that are part of the problem?<ul> <li>Can you check the result?</li> <li>Can you improve the performance?</li> </ul> </li> </ol>"}]}